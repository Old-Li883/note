# 正则表达式

原则上是一一对应的关系，有些时候有一些统配的规则

## 基本匹配模式

`\d`:数字

`\w`：字母或数字

`.`:匹配一个任意的字符

`*`:匹配多个字符（包括0个）

`+`：表示至少一个字符

`？`：0或1个字符

`{n}`：表示n个字符

`{n,m}`：表示n-m个字符

`[]`：表示范围（在这个位置希望匹配到什么东西）（括号中的^表示“非”的意思）

`|`：表示‘或’匹配

`^`：表示行的开头

`$`：表示行的结尾

`(……)`：表示分组

`(?:……)`:匹配括号中……的正则表达式，但丢弃匹配的子字符串

`(?P<name>……)`：匹配括号中……的正则表达式并创建指定分组。name就是该正则表达式所在分组

`(?P=name)`：匹配一个早起指定分组所匹配的文本

`(?(id|name)ypat|npat)`：检查id或者name（如果是数字则表示第几组：group中的规则）标识的正则表达式是否存在，如果存在则匹配ypat，否则匹配napt

`(?#)`：写注释用的

`(?=……)`：只有在括号中的模式匹配时，才匹配前面的表达式

`(?!……)`：只有在括号的模式不匹配时，才匹配前面的表达式

`(?<=)`：只有括号后面的表达式前面的值（指的是字符串）与括号中的值匹配才会与该正则表达式匹配

## python的re模块

`\`为转义符

以r开头在匹配是就不用考虑在匹配\是要写两个\来进行转义表达了

标准字符转义序列在正则表达式中也适用。如：`r"\n*"`匹配多个换行符号

re是贪婪匹配（就是尽自己最大的能力匹配东西）（这样就有可能把后面所要匹配的东西一起匹配了）

当使用`*`，`+`等匹配多个字符的正则表达时，加上`？`就采用了非贪婪匹配

### re模块中的方法

注：下面“正”表示正则表达式，“字”表示字符串

#### 预编译正则表达式

`compile(正)`：

#### 匹配：

`match(正，字)`：判断正则表达式是否匹配，从头开始匹配，知道正则表达式匹配完，字符串不一定要匹配完

**注**：如果正则表达式中最后面有$则表示要匹配整个字符串

#### 寻找：

`search(正，字)`：寻找字符串里面有没有与正则表达式匹配的项

#### 寻找所有：

`findall(正，字)`：寻找字符串中所有与正则表达式匹配的额项

#### 替换：

`sub(正,repl,字)`:将所有与正则表达式匹配的字符串用repl替换

#### 转义字符串：

`escape(string)`：将字符串中所有特殊的正则表达式字符进行转义

#### 切分字符串

`split():把字符串按顺序呢切分成列表，并去掉中间的某一部分`

用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：

```
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c']
```

嗯，无法识别连续的空格，用正则表达式试试：

```
>>> re.split(r'\s+', 'a b   c')
['a', 'b', 'c']
```

无论多少个空格都可以正常分割。加入`,`试试：

```
>>> re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']
```

再加入`;`试试：

```
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```

如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。

#### 分组

在正则表达式中用()来表示一组一组的东西

`group()`

`group(0)`：表示全部的所匹配的那一个字符串

1,2,3……n表示第n个括号里匹配的东西

`start([group])`：匹配组开始第一个字符所在位置

`end([group])`：匹配组最后一个字符所在位置

`span([group])`:整个组的跨度

`groups()`：输出所有组

#### 正则间注释

`re.VERBOSE`：允许正则间加入注释，正则用两个‘’‘包括，这个东西跟在正则的后面

